/* -*- c++ -*- */
/*
 * Copyright 2012 Free Software Foundation, Inc.
 *
 * This file was generated by gr_modtool, a tool from the GNU Radio framework
 * This file is a part of gr-mesa
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <cppunit/TextTestRunner.h>
#include <cppunit/XmlOutputter.h>

#include <gnuradio/unittests.h>
#include "qa_mesa.h"
#include <iostream>
#include <fstream>

#include "AutoDopplerCorrect_impl.h"

// volk
#include <volk/volk.h>

// Some carry-forward tricks from file_sink_base.cc
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// win32 (mingw/msvc) specific
#ifdef HAVE_IO_H
#include <io.h>
#endif
#ifdef O_BINARY
#define	OUR_O_BINARY O_BINARY
#else
#define	OUR_O_BINARY 0
#endif

// should be handled via configure
#ifdef O_LARGEFILE
#define	OUR_O_LARGEFILE	O_LARGEFILE
#else
#define	OUR_O_LARGEFILE 0
#endif

#include "SourceSelector_impl.h"

FILE *d_fp = NULL;

using namespace std;
using namespace gr::mesa;

bool open(const char *filename)
{
  // we use the open system call to get access to the O_LARGEFILE flag.
  int fd;
  int flags;
  flags = O_RDONLY | OUR_O_LARGEFILE | OUR_O_BINARY;

  if((fd = ::open(filename, flags)) < 0){
    perror(filename);
    return false;
  }
  if(d_fp) {		// if we've already got a new one open, close it
    fclose(d_fp);
    d_fp = NULL;
  }

  if((d_fp = fdopen (fd, "rb")) == NULL) {
    perror (filename);
    close(fd);        // don't leak file descriptor if fdopen fails.
  }

  // Finalize setup
  bool fileOpen = d_fp != 0;

  return fileOpen;
}

void close() {
	if (d_fp) {
		fclose(d_fp);
		d_fp = NULL;
	}
}


int
main (int argc, char **argv)
{
	/*
  CppUnit::TextTestRunner runner;
  std::ofstream xmlfile(get_unittest_path("mesa.xml").c_str());
  CppUnit::XmlOutputter *xmlout = new CppUnit::XmlOutputter(&runner.result(), xmlfile);

  runner.addTest(qa_mesa::suite());
  runner.setOutputter(xmlout);

  bool was_successful = runner.run("", false);

  return was_successful ? 0 : 1;
  */

	// Open file
	string filename = "/opt/sdr/gnuradio/gnuradio_recordings/NOAA_weather_radio_162.425MHz_NBFM_600KSPS_48KFilter.iq";

	bool fileOpen = open(filename.c_str());

	if (!fileOpen) {
		std::cout << "ERROR: Unable to open " << filename << std::endl;
		return 1;
	}

	// Allocate memory and get a block of data
	gr_complex *samples;
	gr_complex *out;
	int numFrames = 6;
	int fftSize = 1024;
	int noutput_items = numFrames * fftSize;

	size_t memAlignment = volk_get_alignment();
	samples = (gr_complex *)volk_malloc(noutput_items*sizeof(gr_complex),memAlignment);
	out = (gr_complex *)volk_malloc(noutput_items*sizeof(gr_complex),memAlignment);


 	// Read samples
	long itemsRead;
	for (int i=0;i<100;i++) // read off some data.  First block seems messy
		itemsRead = fread((void *)samples, sizeof(gr_complex), noutput_items, (FILE*)d_fp);

	if (itemsRead < noutput_items) {
		volk_free(samples);
		volk_free(out);
		std::cout << "ERROR: Unable to read " << noutput_items << " samples from file.  Check file size." << std::endl;
		close();
		return 1;
	}

	// ---------------------------------------------------------------
	// Signal Processing test
	float radio_freq = 162.425e6;
	float samp_rate = 600000.0;
	float maxDrift = 4000.0;
	float expectedWidth = 5000.00;
	float minWidth = 2000.0;
	int shiftHoldTime = 2000.0;
	float holdUpSec = 10.0;
	float squelchThreshold = -80.0;

	AutoDopplerCorrect_impl *pAutoDoppler=NULL;


	pAutoDoppler = new AutoDopplerCorrect_impl(radio_freq, samp_rate, maxDrift, minWidth, expectedWidth, shiftHoldTime, fftSize,squelchThreshold, numFrames, holdUpSec, false,AUTODOPPLER_METHOD_CLOSESTSIGNAL);

	// ---------------------------------------------------------------

	int procResult;

	procResult = pAutoDoppler->processData(noutput_items,samples,out,NULL,true);

	// Release auto corrector
	if (pAutoDoppler)
		delete pAutoDoppler;

	// release memory
	if (samples)
		volk_free(samples);

	if (out)
		volk_free(out);

	// close file
	close();

	std::cout << "Done." << std::endl;

	return 0;
}
